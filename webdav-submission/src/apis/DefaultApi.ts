// tslint:disable
/**
 * Submissions
 * This API specifies the submissions service, as accessed by the web admin UI used by students, lecturers and tutors. 
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    Assignment,
    AssignmentFromJSON,
    AssignmentToJSON,
    Invitation,
    InvitationFromJSON,
    InvitationToJSON,
    Submission,
    SubmissionFromJSON,
    SubmissionToJSON,
    Tutor,
    TutorFromJSON,
    TutorToJSON,
    Tutorial,
    TutorialFromJSON,
    TutorialToJSON,
} from '../models';

export interface AssignmentsAssignmentIDDeleteRequest {
    assignmentID: string;
}

export interface AssignmentsAssignmentIDGetRequest {
    assignmentID: string;
}

export interface AssignmentsAssignmentIDPutRequest {
    assignmentID: string;
    assignment: Assignment;
}

export interface InvitationsInvitationIDModePostRequest {
    invitationID: string;
    mode: InvitationsInvitationIDModePostModeEnum;
}

export interface LectureLectureIDAssignmentsGetRequest {
    lectureID: number;
}

export interface LectureLectureIDAssignmentsPostRequest {
    lectureID: number;
    assignment: Assignment;
}

export interface LectureLectureIDSubmissionsGetRequest {
    lectureID: number;
}

export interface LectureLectureIDSubmissionsPostRequest {
    lectureID: number;
    submission: Submission;
}

export interface LectureLectureIDTutorialsGetRequest {
    lectureID: number;
}

export interface LectureLectureIDTutorialsPostRequest {
    lectureID: number;
    tutorial: Tutorial;
}

export interface LecturesLectureIDInvitationsGetRequest {
    lectureID: number;
}

export interface SubmissionsSubmissionIDDeleteRequest {
    submissionID: string;
}

export interface SubmissionsSubmissionIDGetRequest {
    submissionID: string;
}

export interface SubmissionsSubmissionIDInvitationsGetRequest {
    submissionID: string;
}

export interface SubmissionsSubmissionIDInvitationsPostRequest {
    submissionID: string;
    invitation: Invitation;
}

export interface SubmissionsSubmissionIDPutRequest {
    submissionID: string;
    submission: Submission;
}

export interface TokenTokenJoinPostRequest {
    token: string;
}

export interface TutorialsTutorialIDTutorsGetRequest {
    tutorialID: number;
}

export interface TutorialsTutorialIDTutorsUserIDDeleteRequest {
    tutorialID: number;
    userID: number;
}

export interface TutorialsTutorialIDTutorsUserIDGetRequest {
    tutorialID: number;
    userID: number;
}

export interface TutorialsTutorialIDTutorsUserIDPostRequest {
    tutorialID: number;
    userID: number;
}


/**
 */
function assignmentsAssignmentIDDeleteRaw<T>(requestParameters: AssignmentsAssignmentIDDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.assignmentID === null || requestParameters.assignmentID === undefined) {
        throw new runtime.RequiredError('assignmentID','Required parameter requestParameters.assignmentID was null or undefined when calling assignmentsAssignmentIDDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/assignments/{assignmentID}`.replace(`{${"assignmentID"}}`, encodeURIComponent(String(requestParameters.assignmentID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
*/
export function assignmentsAssignmentIDDelete<T>(requestParameters: AssignmentsAssignmentIDDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return assignmentsAssignmentIDDeleteRaw(requestParameters, requestConfig);
}

/**
 */
function assignmentsAssignmentIDGetRaw<T>(requestParameters: AssignmentsAssignmentIDGetRequest, requestConfig: runtime.TypedQueryConfig<T, Assignment> = {}): QueryConfig<T> {
    if (requestParameters.assignmentID === null || requestParameters.assignmentID === undefined) {
        throw new runtime.RequiredError('assignmentID','Required parameter requestParameters.assignmentID was null or undefined when calling assignmentsAssignmentIDGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/assignments/{assignmentID}`.replace(`{${"assignmentID"}}`, encodeURIComponent(String(requestParameters.assignmentID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(AssignmentFromJSON(body), text);
    }

    return config;
}

/**
*/
export function assignmentsAssignmentIDGet<T>(requestParameters: AssignmentsAssignmentIDGetRequest, requestConfig?: runtime.TypedQueryConfig<T, Assignment>): QueryConfig<T> {
    return assignmentsAssignmentIDGetRaw(requestParameters, requestConfig);
}

/**
 */
function assignmentsAssignmentIDPutRaw<T>(requestParameters: AssignmentsAssignmentIDPutRequest, requestConfig: runtime.TypedQueryConfig<T, Assignment> = {}): QueryConfig<T> {
    if (requestParameters.assignmentID === null || requestParameters.assignmentID === undefined) {
        throw new runtime.RequiredError('assignmentID','Required parameter requestParameters.assignmentID was null or undefined when calling assignmentsAssignmentIDPut.');
    }

    if (requestParameters.assignment === null || requestParameters.assignment === undefined) {
        throw new runtime.RequiredError('assignment','Required parameter requestParameters.assignment was null or undefined when calling assignmentsAssignmentIDPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/assignments/{assignmentID}`.replace(`{${"assignmentID"}}`, encodeURIComponent(String(requestParameters.assignmentID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters || AssignmentToJSON(requestParameters.assignment),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(AssignmentFromJSON(body), text);
    }

    return config;
}

/**
*/
export function assignmentsAssignmentIDPut<T>(requestParameters: AssignmentsAssignmentIDPutRequest, requestConfig?: runtime.TypedQueryConfig<T, Assignment>): QueryConfig<T> {
    return assignmentsAssignmentIDPutRaw(requestParameters, requestConfig);
}

/**
 */
function invitationsGetRaw<T>( requestConfig: runtime.TypedQueryConfig<T, Array<Invitation>> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/invitations`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(InvitationFromJSON), text);
    }

    return config;
}

/**
*/
export function invitationsGet<T>( requestConfig?: runtime.TypedQueryConfig<T, Array<Invitation>>): QueryConfig<T> {
    return invitationsGetRaw( requestConfig);
}

/**
 */
function invitationsInvitationIDModePostRaw<T>(requestParameters: InvitationsInvitationIDModePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.invitationID === null || requestParameters.invitationID === undefined) {
        throw new runtime.RequiredError('invitationID','Required parameter requestParameters.invitationID was null or undefined when calling invitationsInvitationIDModePost.');
    }

    if (requestParameters.mode === null || requestParameters.mode === undefined) {
        throw new runtime.RequiredError('mode','Required parameter requestParameters.mode was null or undefined when calling invitationsInvitationIDModePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/invitations/{invitationID}/{mode}`.replace(`{${"invitationID"}}`, encodeURIComponent(String(requestParameters.invitationID))).replace(`{${"mode"}}`, encodeURIComponent(String(requestParameters.mode))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
*/
export function invitationsInvitationIDModePost<T>(requestParameters: InvitationsInvitationIDModePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return invitationsInvitationIDModePostRaw(requestParameters, requestConfig);
}

/**
 */
function lectureLectureIDAssignmentsGetRaw<T>(requestParameters: LectureLectureIDAssignmentsGetRequest, requestConfig: runtime.TypedQueryConfig<T, Array<Assignment>> = {}): QueryConfig<T> {
    if (requestParameters.lectureID === null || requestParameters.lectureID === undefined) {
        throw new runtime.RequiredError('lectureID','Required parameter requestParameters.lectureID was null or undefined when calling lectureLectureIDAssignmentsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/lecture/{lectureID}/assignments`.replace(`{${"lectureID"}}`, encodeURIComponent(String(requestParameters.lectureID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(AssignmentFromJSON), text);
    }

    return config;
}

/**
*/
export function lectureLectureIDAssignmentsGet<T>(requestParameters: LectureLectureIDAssignmentsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<Assignment>>): QueryConfig<T> {
    return lectureLectureIDAssignmentsGetRaw(requestParameters, requestConfig);
}

/**
 * Add an new Assignment to a lecture.
 */
function lectureLectureIDAssignmentsPostRaw<T>(requestParameters: LectureLectureIDAssignmentsPostRequest, requestConfig: runtime.TypedQueryConfig<T, Assignment> = {}): QueryConfig<T> {
    if (requestParameters.lectureID === null || requestParameters.lectureID === undefined) {
        throw new runtime.RequiredError('lectureID','Required parameter requestParameters.lectureID was null or undefined when calling lectureLectureIDAssignmentsPost.');
    }

    if (requestParameters.assignment === null || requestParameters.assignment === undefined) {
        throw new runtime.RequiredError('assignment','Required parameter requestParameters.assignment was null or undefined when calling lectureLectureIDAssignmentsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/lecture/{lectureID}/assignments`.replace(`{${"lectureID"}}`, encodeURIComponent(String(requestParameters.lectureID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || AssignmentToJSON(requestParameters.assignment),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(AssignmentFromJSON(body), text);
    }

    return config;
}

/**
* Add an new Assignment to a lecture.
*/
export function lectureLectureIDAssignmentsPost<T>(requestParameters: LectureLectureIDAssignmentsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, Assignment>): QueryConfig<T> {
    return lectureLectureIDAssignmentsPostRaw(requestParameters, requestConfig);
}

/**
 */
function lectureLectureIDSubmissionsGetRaw<T>(requestParameters: LectureLectureIDSubmissionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, Array<Submission>> = {}): QueryConfig<T> {
    if (requestParameters.lectureID === null || requestParameters.lectureID === undefined) {
        throw new runtime.RequiredError('lectureID','Required parameter requestParameters.lectureID was null or undefined when calling lectureLectureIDSubmissionsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/lecture/{lectureID}/submissions`.replace(`{${"lectureID"}}`, encodeURIComponent(String(requestParameters.lectureID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(SubmissionFromJSON), text);
    }

    return config;
}

/**
*/
export function lectureLectureIDSubmissionsGet<T>(requestParameters: LectureLectureIDSubmissionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<Submission>>): QueryConfig<T> {
    return lectureLectureIDSubmissionsGetRaw(requestParameters, requestConfig);
}

/**
 * Add an new submission to a lecture.
 */
function lectureLectureIDSubmissionsPostRaw<T>(requestParameters: LectureLectureIDSubmissionsPostRequest, requestConfig: runtime.TypedQueryConfig<T, Submission> = {}): QueryConfig<T> {
    if (requestParameters.lectureID === null || requestParameters.lectureID === undefined) {
        throw new runtime.RequiredError('lectureID','Required parameter requestParameters.lectureID was null or undefined when calling lectureLectureIDSubmissionsPost.');
    }

    if (requestParameters.submission === null || requestParameters.submission === undefined) {
        throw new runtime.RequiredError('submission','Required parameter requestParameters.submission was null or undefined when calling lectureLectureIDSubmissionsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/lecture/{lectureID}/submissions`.replace(`{${"lectureID"}}`, encodeURIComponent(String(requestParameters.lectureID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || SubmissionToJSON(requestParameters.submission),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(SubmissionFromJSON(body), text);
    }

    return config;
}

/**
* Add an new submission to a lecture.
*/
export function lectureLectureIDSubmissionsPost<T>(requestParameters: LectureLectureIDSubmissionsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, Submission>): QueryConfig<T> {
    return lectureLectureIDSubmissionsPostRaw(requestParameters, requestConfig);
}

/**
 */
function lectureLectureIDTutorialsGetRaw<T>(requestParameters: LectureLectureIDTutorialsGetRequest, requestConfig: runtime.TypedQueryConfig<T, Array<Tutorial>> = {}): QueryConfig<T> {
    if (requestParameters.lectureID === null || requestParameters.lectureID === undefined) {
        throw new runtime.RequiredError('lectureID','Required parameter requestParameters.lectureID was null or undefined when calling lectureLectureIDTutorialsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/lecture/{lectureID}/tutorials`.replace(`{${"lectureID"}}`, encodeURIComponent(String(requestParameters.lectureID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(TutorialFromJSON), text);
    }

    return config;
}

/**
*/
export function lectureLectureIDTutorialsGet<T>(requestParameters: LectureLectureIDTutorialsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<Tutorial>>): QueryConfig<T> {
    return lectureLectureIDTutorialsGetRaw(requestParameters, requestConfig);
}

/**
 * Add an new Tutorial to a lecture.
 */
function lectureLectureIDTutorialsPostRaw<T>(requestParameters: LectureLectureIDTutorialsPostRequest, requestConfig: runtime.TypedQueryConfig<T, Tutorial> = {}): QueryConfig<T> {
    if (requestParameters.lectureID === null || requestParameters.lectureID === undefined) {
        throw new runtime.RequiredError('lectureID','Required parameter requestParameters.lectureID was null or undefined when calling lectureLectureIDTutorialsPost.');
    }

    if (requestParameters.tutorial === null || requestParameters.tutorial === undefined) {
        throw new runtime.RequiredError('tutorial','Required parameter requestParameters.tutorial was null or undefined when calling lectureLectureIDTutorialsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/lecture/{lectureID}/tutorials`.replace(`{${"lectureID"}}`, encodeURIComponent(String(requestParameters.lectureID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || TutorialToJSON(requestParameters.tutorial),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(TutorialFromJSON(body), text);
    }

    return config;
}

/**
* Add an new Tutorial to a lecture.
*/
export function lectureLectureIDTutorialsPost<T>(requestParameters: LectureLectureIDTutorialsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, Tutorial>): QueryConfig<T> {
    return lectureLectureIDTutorialsPostRaw(requestParameters, requestConfig);
}

/**
 */
function lecturesLectureIDInvitationsGetRaw<T>(requestParameters: LecturesLectureIDInvitationsGetRequest, requestConfig: runtime.TypedQueryConfig<T, Array<Invitation>> = {}): QueryConfig<T> {
    if (requestParameters.lectureID === null || requestParameters.lectureID === undefined) {
        throw new runtime.RequiredError('lectureID','Required parameter requestParameters.lectureID was null or undefined when calling lecturesLectureIDInvitationsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/lectures/{lectureID}/invitations`.replace(`{${"lectureID"}}`, encodeURIComponent(String(requestParameters.lectureID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(InvitationFromJSON), text);
    }

    return config;
}

/**
*/
export function lecturesLectureIDInvitationsGet<T>(requestParameters: LecturesLectureIDInvitationsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<Invitation>>): QueryConfig<T> {
    return lecturesLectureIDInvitationsGetRaw(requestParameters, requestConfig);
}

/**
 */
function submissionsSubmissionIDDeleteRaw<T>(requestParameters: SubmissionsSubmissionIDDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.submissionID === null || requestParameters.submissionID === undefined) {
        throw new runtime.RequiredError('submissionID','Required parameter requestParameters.submissionID was null or undefined when calling submissionsSubmissionIDDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/submissions/{submissionID}`.replace(`{${"submissionID"}}`, encodeURIComponent(String(requestParameters.submissionID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
*/
export function submissionsSubmissionIDDelete<T>(requestParameters: SubmissionsSubmissionIDDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return submissionsSubmissionIDDeleteRaw(requestParameters, requestConfig);
}

/**
 */
function submissionsSubmissionIDGetRaw<T>(requestParameters: SubmissionsSubmissionIDGetRequest, requestConfig: runtime.TypedQueryConfig<T, Submission> = {}): QueryConfig<T> {
    if (requestParameters.submissionID === null || requestParameters.submissionID === undefined) {
        throw new runtime.RequiredError('submissionID','Required parameter requestParameters.submissionID was null or undefined when calling submissionsSubmissionIDGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/submissions/{submissionID}`.replace(`{${"submissionID"}}`, encodeURIComponent(String(requestParameters.submissionID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(SubmissionFromJSON(body), text);
    }

    return config;
}

/**
*/
export function submissionsSubmissionIDGet<T>(requestParameters: SubmissionsSubmissionIDGetRequest, requestConfig?: runtime.TypedQueryConfig<T, Submission>): QueryConfig<T> {
    return submissionsSubmissionIDGetRaw(requestParameters, requestConfig);
}

/**
 */
function submissionsSubmissionIDInvitationsGetRaw<T>(requestParameters: SubmissionsSubmissionIDInvitationsGetRequest, requestConfig: runtime.TypedQueryConfig<T, Array<Invitation>> = {}): QueryConfig<T> {
    if (requestParameters.submissionID === null || requestParameters.submissionID === undefined) {
        throw new runtime.RequiredError('submissionID','Required parameter requestParameters.submissionID was null or undefined when calling submissionsSubmissionIDInvitationsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/submissions/{submissionID}/invitations`.replace(`{${"submissionID"}}`, encodeURIComponent(String(requestParameters.submissionID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(InvitationFromJSON), text);
    }

    return config;
}

/**
*/
export function submissionsSubmissionIDInvitationsGet<T>(requestParameters: SubmissionsSubmissionIDInvitationsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<Invitation>>): QueryConfig<T> {
    return submissionsSubmissionIDInvitationsGetRaw(requestParameters, requestConfig);
}

/**
 */
function submissionsSubmissionIDInvitationsPostRaw<T>(requestParameters: SubmissionsSubmissionIDInvitationsPostRequest, requestConfig: runtime.TypedQueryConfig<T, Invitation> = {}): QueryConfig<T> {
    if (requestParameters.submissionID === null || requestParameters.submissionID === undefined) {
        throw new runtime.RequiredError('submissionID','Required parameter requestParameters.submissionID was null or undefined when calling submissionsSubmissionIDInvitationsPost.');
    }

    if (requestParameters.invitation === null || requestParameters.invitation === undefined) {
        throw new runtime.RequiredError('invitation','Required parameter requestParameters.invitation was null or undefined when calling submissionsSubmissionIDInvitationsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/submissions/{submissionID}/invitations`.replace(`{${"submissionID"}}`, encodeURIComponent(String(requestParameters.submissionID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || InvitationToJSON(requestParameters.invitation),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(InvitationFromJSON(body), text);
    }

    return config;
}

/**
*/
export function submissionsSubmissionIDInvitationsPost<T>(requestParameters: SubmissionsSubmissionIDInvitationsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, Invitation>): QueryConfig<T> {
    return submissionsSubmissionIDInvitationsPostRaw(requestParameters, requestConfig);
}

/**
 */
function submissionsSubmissionIDPutRaw<T>(requestParameters: SubmissionsSubmissionIDPutRequest, requestConfig: runtime.TypedQueryConfig<T, Submission> = {}): QueryConfig<T> {
    if (requestParameters.submissionID === null || requestParameters.submissionID === undefined) {
        throw new runtime.RequiredError('submissionID','Required parameter requestParameters.submissionID was null or undefined when calling submissionsSubmissionIDPut.');
    }

    if (requestParameters.submission === null || requestParameters.submission === undefined) {
        throw new runtime.RequiredError('submission','Required parameter requestParameters.submission was null or undefined when calling submissionsSubmissionIDPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/submissions/{submissionID}`.replace(`{${"submissionID"}}`, encodeURIComponent(String(requestParameters.submissionID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters || SubmissionToJSON(requestParameters.submission),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(SubmissionFromJSON(body), text);
    }

    return config;
}

/**
*/
export function submissionsSubmissionIDPut<T>(requestParameters: SubmissionsSubmissionIDPutRequest, requestConfig?: runtime.TypedQueryConfig<T, Submission>): QueryConfig<T> {
    return submissionsSubmissionIDPutRaw(requestParameters, requestConfig);
}

/**
 * Join by code
 */
function tokenTokenJoinPostRaw<T>(requestParameters: TokenTokenJoinPostRequest, requestConfig: runtime.TypedQueryConfig<T, Submission> = {}): QueryConfig<T> {
    if (requestParameters.token === null || requestParameters.token === undefined) {
        throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling tokenTokenJoinPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/token/{token}/join`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(SubmissionFromJSON(body), text);
    }

    return config;
}

/**
* Join by code
*/
export function tokenTokenJoinPost<T>(requestParameters: TokenTokenJoinPostRequest, requestConfig?: runtime.TypedQueryConfig<T, Submission>): QueryConfig<T> {
    return tokenTokenJoinPostRaw(requestParameters, requestConfig);
}

/**
 */
function tutorialsTutorialIDTutorsGetRaw<T>(requestParameters: TutorialsTutorialIDTutorsGetRequest, requestConfig: runtime.TypedQueryConfig<T, Array<Tutor>> = {}): QueryConfig<T> {
    if (requestParameters.tutorialID === null || requestParameters.tutorialID === undefined) {
        throw new runtime.RequiredError('tutorialID','Required parameter requestParameters.tutorialID was null or undefined when calling tutorialsTutorialIDTutorsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/tutorials/{tutorialID}/tutors`.replace(`{${"tutorialID"}}`, encodeURIComponent(String(requestParameters.tutorialID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(TutorFromJSON), text);
    }

    return config;
}

/**
*/
export function tutorialsTutorialIDTutorsGet<T>(requestParameters: TutorialsTutorialIDTutorsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<Tutor>>): QueryConfig<T> {
    return tutorialsTutorialIDTutorsGetRaw(requestParameters, requestConfig);
}

/**
 */
function tutorialsTutorialIDTutorsUserIDDeleteRaw<T>(requestParameters: TutorialsTutorialIDTutorsUserIDDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.tutorialID === null || requestParameters.tutorialID === undefined) {
        throw new runtime.RequiredError('tutorialID','Required parameter requestParameters.tutorialID was null or undefined when calling tutorialsTutorialIDTutorsUserIDDelete.');
    }

    if (requestParameters.userID === null || requestParameters.userID === undefined) {
        throw new runtime.RequiredError('userID','Required parameter requestParameters.userID was null or undefined when calling tutorialsTutorialIDTutorsUserIDDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/tutorials/{tutorialID}/tutors/{userID}`.replace(`{${"tutorialID"}}`, encodeURIComponent(String(requestParameters.tutorialID))).replace(`{${"userID"}}`, encodeURIComponent(String(requestParameters.userID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
*/
export function tutorialsTutorialIDTutorsUserIDDelete<T>(requestParameters: TutorialsTutorialIDTutorsUserIDDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return tutorialsTutorialIDTutorsUserIDDeleteRaw(requestParameters, requestConfig);
}

/**
 */
function tutorialsTutorialIDTutorsUserIDGetRaw<T>(requestParameters: TutorialsTutorialIDTutorsUserIDGetRequest, requestConfig: runtime.TypedQueryConfig<T, Tutor> = {}): QueryConfig<T> {
    if (requestParameters.tutorialID === null || requestParameters.tutorialID === undefined) {
        throw new runtime.RequiredError('tutorialID','Required parameter requestParameters.tutorialID was null or undefined when calling tutorialsTutorialIDTutorsUserIDGet.');
    }

    if (requestParameters.userID === null || requestParameters.userID === undefined) {
        throw new runtime.RequiredError('userID','Required parameter requestParameters.userID was null or undefined when calling tutorialsTutorialIDTutorsUserIDGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/tutorials/{tutorialID}/tutors/{userID}`.replace(`{${"tutorialID"}}`, encodeURIComponent(String(requestParameters.tutorialID))).replace(`{${"userID"}}`, encodeURIComponent(String(requestParameters.userID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(TutorFromJSON(body), text);
    }

    return config;
}

/**
*/
export function tutorialsTutorialIDTutorsUserIDGet<T>(requestParameters: TutorialsTutorialIDTutorsUserIDGetRequest, requestConfig?: runtime.TypedQueryConfig<T, Tutor>): QueryConfig<T> {
    return tutorialsTutorialIDTutorsUserIDGetRaw(requestParameters, requestConfig);
}

/**
 */
function tutorialsTutorialIDTutorsUserIDPostRaw<T>(requestParameters: TutorialsTutorialIDTutorsUserIDPostRequest, requestConfig: runtime.TypedQueryConfig<T, Array<Tutor>> = {}): QueryConfig<T> {
    if (requestParameters.tutorialID === null || requestParameters.tutorialID === undefined) {
        throw new runtime.RequiredError('tutorialID','Required parameter requestParameters.tutorialID was null or undefined when calling tutorialsTutorialIDTutorsUserIDPost.');
    }

    if (requestParameters.userID === null || requestParameters.userID === undefined) {
        throw new runtime.RequiredError('userID','Required parameter requestParameters.userID was null or undefined when calling tutorialsTutorialIDTutorsUserIDPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/tutorials/{tutorialID}/tutors/{userID}`.replace(`{${"tutorialID"}}`, encodeURIComponent(String(requestParameters.tutorialID))).replace(`{${"userID"}}`, encodeURIComponent(String(requestParameters.userID))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(TutorFromJSON), text);
    }

    return config;
}

/**
*/
export function tutorialsTutorialIDTutorsUserIDPost<T>(requestParameters: TutorialsTutorialIDTutorsUserIDPostRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<Tutor>>): QueryConfig<T> {
    return tutorialsTutorialIDTutorsUserIDPostRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum InvitationsInvitationIDModePostModeEnum {
    Accept = 'accept',
    Decline = 'decline',
    Withdraw = 'withdraw'
}
